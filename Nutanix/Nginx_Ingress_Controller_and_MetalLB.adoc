### This guide is meant to outline the procedure for installing the Nginx Ingress Controller and MetalLB load balancer on a running SUSE CaaS Platform installation on an on-premesis compute infrastructure. A follow on document covers installing SUSE Cloud Application Platform using these resources

NOTE: This guide follows a methodology of populating a single variables file for the entire operation and then sourcing that file at the beginning of each major step

ATTENTION: This guide assumes a SUSE CaaS Platform cluster is fully installed and running on an on-premesis compute infrastructure. A DNS service for the cluster nodesMay applications, including SUSE CAP, require additional resources such as a default Storage Class to be configured.

NOTE: Specifically for supporting SUSE CAP, a wild-card DNS record that matches the SVC_FQDN below must be created before deploying CAP
### Create and populate this variables file on the administrative workstation from which the kubectl and helm commands will be run:

----
### START Variables for creating the TSL/SSL certificates and keys ###
# Name of the root CA file. (.key will be appended to it during key creation)
export ROOTCA_NAME=
# (OPTIONAL) Document the root CA cert passphrase here or somewhere else
ROOTCA_PASSPHRASE=
## Document the values to used in creating the root CA certificate:
# Two letter country code
export COUNTRY_NAME=
# State or Province
export STATE_NAME=
# Locality or City
export LOCALITY_NAME=
# Major organization or company
export ORGANIZATION_NAME=
# OU or section
export ORGANIZATIONAL_UNIT_NAME=
# Server FQDN or service domain name, i.e. scf.caasp.local
export COMMON_NAME=
export EMAIL_ADDRESS=
# The FQDN of the external URL that clients will connect to, can be the same a COMMON_NAME in some environments
export SVC_FQDN=
### END Variables for creating the TSL/SSL certificates and keys ###

### START Variables for instantiating the MetalLB load balancer ###
# IP range is expressed as START-END, i.e. 10.0.0.10-10.0.0.19 or 10.0.0.10-10.0.0.10
export IP_RANGE=

----



### Create the TLS/SSL certificates and keys

.Source the variables file (i.e. `source <filename>`), then run the following commands

* Assign the passphrase
----
openssl genrsa -des3 -out ${ROOTCA_NAME}.key 2048
----
* Provide the root CA private key passphrase when prompted
----
openssl req -x509 -new -nodes -key ${ROOTCA_NAME}.key  -subj "/C=${COUNTRY_NAME}/ST=${STATE_NAME}/L=${LOCALITY_NAME}/O=${ORGANIZATION_NAME}/OU=${ORGANIZATIONAL_UNIT_NAME}/CN=${COMMON_NAME}/emailAddress=${EMAIL_ADDRESS}" -sha256 -days 1825 -out ${ROOTCA_NAME}.pem
----
* Generate the site private key
----
openssl genrsa -out ${SVC_FQDN}.key 2048
----
* Generate the site certificate signing request
----
openssl req -new -key ${SVC_FQDN}.key -subj "/C=${COUNTRY_NAME}/ST=${STATE_NAME}/L=${LOCALITY_NAME}/O=${ORGANIZATION_NAME}/OU=${ORGANIZATIONAL_UNIT_NAME}/CN=${COMMON_NAME}/emailAddress=${EMAIL_ADDRESS}" -out ${SVC_FQDN}.csr
----
* Create the .ext file
----
cat <<EOF> ${SVC_FQDN}.ext
authorityKeyIdentifier=keyid,issuer

basicConstraints=CA:FALSE

keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment

subjectAltName = @alt_names

[alt_names]

DNS.1 = ${SVC_FQDN}

DNS.2 = *.${SVC_FQDN}

DNS.3 = uaa.${SVC_FQDN}

DNS.4 = *.uaa.${SVC_FQDN}
EOF
----
* Create the x509 cert
** Provide the root CA private key passphrase when prompted
----
openssl x509 -req -in ${SVC_FQDN}.csr -CA ${ROOTCA_NAME}.pem -CAkey ${ROOTCA_NAME}.key -CAcreateserial -out ${SVC_FQDN}.crt -days 1825 -sha256 -extfile ${SVC_FQDN}.ext
----
* (OPTIONAL) Verify the cert public key, site private key, and certificate signing request files were created correctly and all match
** The resulting md5 hashes should all be the same
----
openssl x509 -noout -modulus -in ${SVC_FQDN}.crt | openssl md5
openssl rsa -noout -modulus -in ${SVC_FQDN}.key | openssl md5
openssl req -noout -modulus -in ${SVC_FQDN}.csr | openssl md5
----


### Deploy the MetalLB load balancer

.Source the variables file (i.e. `source <filename>`), then run the following commands

CAUTION: These instructions come from https://metallb.universe.tf/installation/. It is highly recommended that the user review this site thoroughly for any changes in the installation procedure before continuing. 

* Verify the correct Kubernetes cluster is targeted: `kubectl config get-clusters` 
* Install MetalLB
----
kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.9.3/manifests/namespace.yaml
kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.9.3/manifests/metallb.yaml
# On first install only
kubectl create secret generic -n metallb-system memberlist --from-literal=secretkey="$(openssl rand -base64 128)"
----

* Create the MetalLB configuration file for layer 2 routing. See https://metallb.universe.tf/configuration/ for other routing options
----
cat <<EOF> metallb-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  namespace: metallb-system
  name: config
data:
  config: |
    address-pools:
    - name: default
      protocol: layer2
      addresses:
      - ${IP_RANGE}
EOF
----
** Apply the MetalLB configuration ConfigMap: `kubectl apply -f metallb-config.yaml`
*** Verify the configuration was applied correctly (especially review the IP address pool): `kubectl get configmap config -n metallb-system -o yaml`
*** Verify the MetalLB load balancer is running: `kubectl get all -n metallb-system`

### Deploy the Nginx Ingress Controller

.Source the variables file (i.e. `source <filename>`), then run the following commands

* Create the nginx-ingress namespace: `kubectl create namespace nginx-ingress`
* Prepare the Base64 encoded files for the TLS secret
----
B64_CRT=`bash -c "cat ${SVC_FQDN}.crt | base64 | awk '{print}' ORS='' && echo"`
B64_KEY=`bash -c "cat ${SVC_FQDN}.key | base64 | awk '{print}' ORS='' && echo"`
----

* Create the Kubernetes secret that contains the site certificate file and private key
----
cat <<EOF> ingress-tls-secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: ingress-tls
  namespace: nginx-ingress
data:
  tls.crt: ${B64_CRT}
  tls.key: ${B64_KEY}
type: kubernetes.io/tls
EOF
----
** Apply the Kubernetes secret: `kubectl apply -f ingress-tls-secret.yaml`

* Using Helm version 3, create the Nginx Ingress Controller
----
helm install  nginx-ingress  suse/nginx-ingress --namespace nginx-ingress --set rbac.create=true --set controller.service.externalTrafficPolicy=Local --set controller.publishService.enabled=true --set "tcp.20000=kubecf/tcp-router-tcp-router-public:20000" --set "tcp.20001=kubecf/tcp-router-tcp-router-public:20001" --set "tcp.20002=kubecf/tcp-router-tcp-router-public:20002" --set "tcp.20003=kubecf/tcp-router-tcp-router-public:20003" --set "tcp.20004=kubecf/tcp-router-tcp-router-public:20004" --set "tcp.20005=kubecf/tcp-router-tcp-router-public:20005" --set "tcp.20006=kubecf/tcp-router-tcp-router-public:20006" --set "tcp.20007=kubecf/tcp-router-tcp-router-public:20007" --set "tcp.20008=kubecf/tcp-router-tcp-router-public:20008" --set "tcp.2222=kubecf/diego-ssh-ssh-proxy-public:2222"
----

* Verify the Nginx ingress controller is communicating with the MetalLB load balancer: `kubectl get svc -n nginx-ingress`
** The ingress controller should have the first IP allocated to MetalLB and show all of the port mappings configured through Helm

### Test Nginx+MetalLB

NOTE: This test will only work if the MetalLB load balancer has at least one configured IP address that is not allocated to a cluster service

.Source the variables file (i.e. `source <filename>`), then run the following commands

* Create the file containing an Nginx webserver deployment and LoadBalancer service
----
cat <<EOF> nginx-metallb-test.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
spec:
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1
        ports:
        - name: http
          containerPort: 80

---
apiVersion: v1
kind: Service
metadata:
  name: nginx
spec:
  ports:
  - name: http
    port: 8080
    protocol: TCP
    targetPort: 80
  selector:
    app: nginx
  type: LoadBalancer
EOF
----
* Create the deployment and service: `kubectl apply -f nginx-metallb-test.yaml`
* Verify the deployment is running: `kubectl get deployments,svc`
** Take note of the EXTERNAL-IP allocated to "service/nginx" 
* (OPTIONAL) Configure local DNS resolution for the IP address allocated to "service/nginx"
* Set this variable to the DNS name or IP address: `URL=""`
* Verify external connectivity to the nginx webserver: `curl http://${URL}:8080`
* When ready, delete the deployment and service: `kubectl delete -f nginx-metallb-test.yaml`
* If needed, remove the local DNS entry for the test deployment




// vim: set syntax=asciidoc:

